// Generated by CoffeeScript 1.8.0

/*
rsmq

A Really Simple Message Queue based on Redis

The MIT License (MIT)

Copyright © 2013-2016 Patrick Liess, http://www.tcs.de

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function() {
  var EventEmitter, RedisInst, RedisSMQ, crypto, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  crypto = require("crypto");

  _ = require("lodash");

  RedisInst = require("redis");

  EventEmitter = require("events").EventEmitter;

  RedisSMQ = (function(_super) {
    __extends(RedisSMQ, _super);

    function RedisSMQ(options) {
      if (options == null) {
        options = {};
      }
      this._initErrors = __bind(this._initErrors, this);
      this._handleError = __bind(this._handleError, this);
      this.setQueueAttributes = __bind(this.setQueueAttributes, this);
      this.sendMessage = __bind(this.sendMessage, this);
      this._receiveMessage = __bind(this._receiveMessage, this);
      this._popMessage = __bind(this._popMessage, this);
      this._createRedisClient = __bind(this._createRedisClient, this);
      this._generalUnsubscribe = __bind(this._generalUnsubscribe, this);
      this._generalSubscribe = __bind(this._generalSubscribe, this);
      this.unsubscribe = __bind(this.unsubscribe, this);
      this.subscribe = __bind(this.subscribe, this);
      this.receiveMessage = __bind(this.receiveMessage, this);
      this.popMessage = __bind(this.popMessage, this);
      this.listQueues = __bind(this.listQueues, this);
      this.getQueueAttributes = __bind(this.getQueueAttributes, this);
      this.deleteQueue = __bind(this.deleteQueue, this);
      this.deleteMessage = __bind(this.deleteMessage, this);
      this.createQueue = __bind(this.createQueue, this);
      this._changeMessageVisibility = __bind(this._changeMessageVisibility, this);
      this.changeMessageVisibility = __bind(this.changeMessageVisibility, this);
      this._getQueue = __bind(this._getQueue, this);
      this.quit = __bind(this.quit, this);
      this.config = _.extend({
        host: "127.0.0.1",
        port: 6379,
        options: {},
        client: null,
        ns: "rsmq"
      }, options);
      this.redisns = this.config.ns + ":";
      this._createRedisClient();
      this._initErrors();
      return;
    }

    RedisSMQ.prototype.quit = function() {
      this.redis.quit();
      this.removeAllListeners();
    };

    RedisSMQ.prototype._getQueue = function(qname, uid, cb) {
      var mc;
      mc = [["hmget", "" + this.redisns + qname + ":Q", "vt", "delay", "maxsize"], ["time"]];
      this.redis.multi(mc).exec((function(_this) {
        return function(err, resp) {
          var ms, q, ts;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (resp[0][0] === null || resp[0][1] === null || resp[0][2] === null) {
            _this._handleError(cb, "queueNotFound");
            return;
          }
          ms = _this._formatZeroPad(Number(resp[1][1]), 6);
          ts = Number(resp[1][0] + ms.toString(10).slice(0, 3));
          q = {
            vt: parseInt(resp[0][0], 10),
            delay: parseInt(resp[0][1], 10),
            maxsize: parseInt(resp[0][2], 10),
            ts: ts
          };
          if (uid) {
            uid = _this._makeid(22);
            q.uid = Number(resp[1][0] + ms).toString(36) + uid;
          }
          cb(null, q);
        };
      })(this));
    };

    RedisSMQ.prototype.changeMessageVisibility = function(options, cb) {
      if (this._validate(options, ["qname", "id", "vt"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, false, (function(_this) {
        return function(err, q) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (_this.changeMessageVisibility_sha1) {
            _this._changeMessageVisibility(options, q, cb);
            return;
          }
          _this.on('scriptload:changeMessageVisibility', function() {
            _this._changeMessageVisibility(options, q, cb);
          });
        };
      })(this));
    };

    RedisSMQ.prototype._changeMessageVisibility = function(options, q, cb) {
      this.redis.evalsha(this.changeMessageVisibility_sha1, 3, "" + this.redisns + options.qname, options.id, q.ts + options.vt * 1000, (function(_this) {
        return function(err, resp) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          cb(null, resp);
        };
      })(this));
    };

    RedisSMQ.prototype.createQueue = function(options, cb) {
      var _ref, _ref1, _ref2;
      options.vt = (_ref = options.vt) != null ? _ref : 30;
      options.delay = (_ref1 = options.delay) != null ? _ref1 : 0;
      options.maxsize = (_ref2 = options.maxsize) != null ? _ref2 : 65536;
      if (this._validate(options, ["qname", "vt", "delay", "maxsize"], cb) === false) {
        return;
      }
      this.redis.time((function(_this) {
        return function(err, resp) {
          var mc;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          mc = [["hsetnx", "" + _this.redisns + options.qname + ":Q", "vt", options.vt], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "delay", options.delay], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "maxsize", options.maxsize], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "created", resp[0]], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "modified", resp[0]]];
          _this.redis.multi(mc).exec(function(err, resp) {
            if (err) {
              _this._handleError(cb, err);
              return;
            }
            if (resp[0] === 0) {
              _this._handleError(cb, "queueExists");
              return;
            }
            _this.redis.sadd("" + _this.redisns + "QUEUES", options.qname, function(err, resp) {
              if (err) {
                _this._handleError(cb, err);
                return;
              }
              cb(null, 1);
            });
          });
        };
      })(this));
    };

    RedisSMQ.prototype.deleteMessage = function(options, cb) {
      var key, mc;
      if (this._validate(options, ["qname", "id"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      mc = [["zrem", key, options.id], ["hdel", "" + key + ":Q", "" + options.id, "" + options.id + ":rc", "" + options.id + ":fr"]];
      this.redis.multi(mc).exec((function(_this) {
        return function(err, resp) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (resp[0] === 1 && resp[1] > 0) {
            cb(null, 1);
          } else {
            cb(null, 0);
          }
        };
      })(this));
    };

    RedisSMQ.prototype.deleteQueue = function(options, cb) {
      var key, mc;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      mc = [["del", "" + key + ":Q"], ["del", key], ["srem", "" + this.redisns + "QUEUES", options.qname]];
      this.redis.multi(mc).exec((function(_this) {
        return function(err, resp) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (resp[0] === 0) {
            _this._handleError(cb, "queueNotFound");
            return;
          }
          cb(null, 1);
        };
      })(this));
    };

    RedisSMQ.prototype.getQueueAttributes = function(options, cb) {
      var key;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      this.redis.time((function(_this) {
        return function(err, resp) {
          var mc;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          mc = [["hmget", "" + key + ":Q", "vt", "delay", "maxsize", "totalrecv", "totalsent", "created", "modified"], ["zcard", key], ["zcount", key, resp[0] + "000", "+inf"]];
          _this.redis.multi(mc).exec(function(err, resp) {
            var o;
            if (err) {
              _this._handleError(cb, err);
              return;
            }
            if (resp[0][0] === null) {
              _this._handleError(cb, "queueNotFound");
              return;
            }
            o = {
              vt: parseInt(resp[0][0], 10),
              delay: parseInt(resp[0][1], 10),
              maxsize: parseInt(resp[0][2], 10),
              totalrecv: parseInt(resp[0][3], 10) || 0,
              totalsent: parseInt(resp[0][4], 10) || 0,
              created: parseInt(resp[0][5], 10),
              modified: parseInt(resp[0][6], 10),
              msgs: resp[1],
              hiddenmsgs: resp[2]
            };
            cb(null, o);
          });
        };
      })(this));
    };

    RedisSMQ.prototype._handleReceivedMessage = function(cb) {
      return (function(_this) {
        return function(err, resp) {
          var o;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (!resp.length) {
            cb(null, {});
            return;
          }
          o = {
            id: resp[0],
            message: resp[1],
            rc: resp[2],
            fr: Number(resp[3]),
            sent: parseInt(parseInt(resp[0].slice(0, 10), 36) / 1000)
          };
          cb(null, o);
        };
      })(this);
    };

    RedisSMQ.prototype.initScript = function(cb) {
      var script_changeMessageVisibility, script_popMessage, script_receiveMessage;
      script_popMessage = 'local msg = redis.call("ZRANGEBYSCORE", KEYS[1], "-inf", KEYS[2], "LIMIT", "0", "1") if #msg == 0 then return {} end redis.call("HINCRBY", KEYS[1] .. ":Q", "totalrecv", 1) local mbody = redis.call("HGET", KEYS[1] .. ":Q", msg[1]) local rc = redis.call("HINCRBY", KEYS[1] .. ":Q", msg[1] .. ":rc", 1) local o = {msg[1], mbody, rc} if rc==1 then table.insert(o, KEYS[2]) else local fr = redis.call("HGET", KEYS[1] .. ":Q", msg[1] .. ":fr") table.insert(o, fr) end redis.call("ZREM", KEYS[1], msg[1]) redis.call("HDEL", KEYS[1] .. ":Q", msg[1], msg[1] .. ":rc", msg[1] .. ":fr") return o';
      script_receiveMessage = 'local msg = redis.call("ZRANGEBYSCORE", KEYS[1], "-inf", KEYS[2], "LIMIT", "0", "1") if #msg == 0 then return {} end redis.call("ZADD", KEYS[1], KEYS[3], msg[1]) redis.call("HINCRBY", KEYS[1] .. ":Q", "totalrecv", 1) local mbody = redis.call("HGET", KEYS[1] .. ":Q", msg[1]) local rc = redis.call("HINCRBY", KEYS[1] .. ":Q", msg[1] .. ":rc", 1) local o = {msg[1], mbody, rc} if rc==1 then redis.call("HSET", KEYS[1] .. ":Q", msg[1] .. ":fr", KEYS[2]) table.insert(o, KEYS[2]) else local fr = redis.call("HGET", KEYS[1] .. ":Q", msg[1] .. ":fr") table.insert(o, fr) end return o';
      script_changeMessageVisibility = 'local msg = redis.call("ZSCORE", KEYS[1], KEYS[2]) if not msg then return 0 end redis.call("ZADD", KEYS[1], KEYS[3], KEYS[2]) return 1';
      this.redis.script("load", script_popMessage, (function(_this) {
        return function(err, resp) {
          if (err) {
            console.log(err);
            return;
          }
          _this.popMessage_sha1 = resp;
          _this.emit('scriptload:popMessage');
        };
      })(this));
      this.redis.script("load", script_receiveMessage, (function(_this) {
        return function(err, resp) {
          if (err) {
            console.log(err);
            return;
          }
          _this.receiveMessage_sha1 = resp;
          _this.emit('scriptload:receiveMessage');
        };
      })(this));
      this.redis.script("load", script_changeMessageVisibility, (function(_this) {
        return function(err, resp) {
          _this.changeMessageVisibility_sha1 = resp;
          _this.emit('scriptload:changeMessageVisibility');
        };
      })(this));
    };

    RedisSMQ.prototype.listQueues = function(cb) {
      this.redis.smembers("" + this.redisns + "QUEUES", (function(_this) {
        return function(err, resp) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          cb(null, resp);
        };
      })(this));
    };

    RedisSMQ.prototype.popMessage = function(options, cb) {
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, false, (function(_this) {
        return function(err, q) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (_this.popMessage_sha1) {
            _this._popMessage(options, q, cb);
            return;
          }
          _this.on('scriptload:popMessage', function() {
            _this._popMessage(options, q, cb);
          });
        };
      })(this));
    };

    RedisSMQ.prototype.receiveMessage = function(options, cb) {
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, false, (function(_this) {
        return function(err, q) {
          var _ref;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          options.vt = (_ref = options.vt) != null ? _ref : q.vt;
          if (_this._validate(options, ["vt"], cb) === false) {
            return;
          }
          if (_this.receiveMessage_sha1) {
            _this._receiveMessage(options, q, cb);
            return;
          }
          _this.on('scriptload:receiveMessage', function() {
            _this._receiveMessage(options, q, cb);
          });
        };
      })(this));
    };

    RedisSMQ.prototype.subscribe = function(options, cb) {
      var _cb, _ref;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      if (this.subscriber == null) {
        this._generalSubscribe();
      }
      if (_ref = options.qname, __indexOf.call(this.subscriber.subscriptions, _ref) < 0) {
        this.subscriber.subscriptions.push(options.qname);
      }
      _cb = (function(_this) {
        return function() {
          _this.emit("subscribed:" + options.qname);
          cb();
        };
      })(this);
      if (this.subscriber.subscribed) {
        _cb();
      } else {
        this.once("subscribed", _cb);
      }
    };

    RedisSMQ.prototype.unsubscribe = function(options, cb) {
      var _idx;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      if (this.subscriber == null) {
        return;
      }
      _idx = this.subscriber.subscriptions.indexOf(options.qname);
      if (_idx >= 0) {
        this.subscriber.subscriptions.splice(_idx, 1);
      }
      this.removeAllListeners("message:" + options.qname);
      this.emit("unsubscribed:" + options.qname);
      cb();
      if (this.subscriber.subscriptions.length <= 0) {
        this._generalUnsubscribe();
      }
    };

    RedisSMQ.prototype._generalSubscribe = function() {
      var _subscriberPrefix;
      _subscriberPrefix = "" + this.redisns + "PUB:";
      this.subscriber = {
        subscriptions: []
      };
      this.subscriber.cli = this._createRedisClient(this, this.subscriber, true);
      this.subscriber.cli.on("psubscribe", (function(_this) {
        return function() {
          _this.subscriber.subscribed = true;
          _this.emit("subscribed");
        };
      })(this));
      this.subscriber.cli.on("pmessage", (function(_this) {
        return function(pattern, channel, uid) {
          var _qname;
          _qname = channel.slice(_subscriberPrefix.length);
          _this.emit("message", _qname, uid);
          if (__indexOf.call(_this.subscriber.subscriptions, _qname) >= 0) {
            _this.emit("message:" + _qname, uid);
          }
        };
      })(this));
      this.subscriber.cli.psubscribe("" + _subscriberPrefix + "*");
    };

    RedisSMQ.prototype._generalUnsubscribe = function() {
      this.subscriber.cli.on("punsubscribe", (function(_this) {
        return function(pattern) {
          _this.emit("unsubscribed");
          _this.subscriber.removeAllListeners();
          _this.subscriber.quit();
          _this.subscriber = null;
        };
      })(this));
      this.subscriber.cli.punsubscribe();
    };

    RedisSMQ.prototype._createRedisClient = function(options, context, force) {
      var _config, _ref, _ref1;
      if (options == null) {
        options = this.config;
      }
      if (context == null) {
        context = this;
      }
      if (force == null) {
        force = false;
      }
      _config = _.extend({
        host: "127.0.0.1",
        port: 6379,
        options: {},
        client: null
      }, options);
      if (!force && ((_ref = _config.client) != null ? (_ref1 = _ref.constructor) != null ? _ref1.name : void 0 : void 0) === "RedisClient") {
        context.redis = _config.client;
      } else {
        context.redis = RedisInst.createClient(_config.port, _config.host, _config.options);
      }
      context.connected = context.redis.connected || false;
      if (context.connected) {
        this.emit("connect");
        this.initScript();
        return;
      }
      context.redis.on("connect", (function(_this) {
        return function() {
          context.connected = true;
          _this.emit("connect", context.redis);
          _this.initScript();
        };
      })(this));
      context.redis.on("error", (function(_this) {
        return function(err) {
          if (err.message.indexOf("ECONNREFUSED")) {
            context.connected = false;
            _this.emit("disconnect", context.redis);
          } else {
            console.error("Redis ERROR", err, context.redis);
            _this.emit("error", context.redis);
          }
        };
      })(this));
      return context.redis;
    };

    RedisSMQ.prototype._popMessage = function(options, q, cb) {
      this.redis.evalsha(this.popMessage_sha1, 2, "" + this.redisns + options.qname, q.ts, this._handleReceivedMessage(cb));
    };

    RedisSMQ.prototype._receiveMessage = function(options, q, cb) {
      this.redis.evalsha(this.receiveMessage_sha1, 3, "" + this.redisns + options.qname, q.ts, q.ts + options.vt * 1000, this._handleReceivedMessage(cb));
    };

    RedisSMQ.prototype.sendMessage = function(options, cb) {
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, true, (function(_this) {
        return function(err, q) {
          var mc, _ref;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          options.delay = (_ref = options.delay) != null ? _ref : q.delay;
          if (_this._validate(options, ["delay"], cb) === false) {
            return;
          }
          if (typeof options.message !== "string") {
            _this._handleError(cb, "messageNotString");
            return;
          }
          if (options.message.length > q.maxsize) {
            _this._handleError(cb, "messageTooLong");
            return;
          }
          mc = [["zadd", "" + _this.redisns + options.qname, q.ts + options.delay * 1000, q.uid], ["hset", "" + _this.redisns + options.qname + ":Q", q.uid, options.message], ["hincrby", "" + _this.redisns + options.qname + ":Q", "totalsent", 1], ["publish", "" + _this.redisns + "PUB:" + options.qname, q.uid]];
          _this.redis.multi(mc).exec(function(err, resp) {
            if (err) {
              _this._handleError(cb, err);
              return;
            }
            cb(null, q.uid);
          });
        };
      })(this));
    };

    RedisSMQ.prototype.setQueueAttributes = function(options, cb) {
      var item, k, key, props, _i, _len;
      props = ["vt", "maxsize", "delay"];
      k = [];
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        item = props[_i];
        if (options[item] != null) {
          k.push(item);
        }
      }
      if (!k.length) {
        this._handleError(cb, "noAttributeSupplied");
        return;
      }
      if (this._validate(options, ["qname"].concat(k), cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      this._getQueue(options.qname, false, (function(_this) {
        return function(err, q) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          _this.redis.time(function(err, resp) {
            var mc, _j, _len1;
            if (err) {
              _this._handleError(cb, err);
              return;
            }
            mc = [["hsetnx", "" + _this.redisns + options.qname + ":Q", "modified", resp[0]]];
            for (_j = 0, _len1 = k.length; _j < _len1; _j++) {
              item = k[_j];
              mc.push(["hset", "" + _this.redisns + options.qname + ":Q", item, options[item]]);
            }
            _this.redis.multi(mc).exec(function(err, resp) {
              if (err) {
                _this._handleError(cb, err);
                return;
              }
              _this.getQueueAttributes(options, cb);
            });
          });
        };
      })(this));
    };

    RedisSMQ.prototype._formatZeroPad = function(num, count) {
      return ((Math.pow(10, count) + num) + "").substr(1);
    };

    RedisSMQ.prototype._handleError = function(cb, err, data) {
      var _err, _ref;
      if (data == null) {
        data = {};
      }
      if (_.isString(err)) {
        _err = new Error();
        _err.name = err;
        _err.message = ((_ref = this._ERRORS) != null ? typeof _ref[err] === "function" ? _ref[err](data) : void 0 : void 0) || "unkown";
      } else {
        _err = err;
      }
      cb(_err);
    };

    RedisSMQ.prototype._initErrors = function() {
      var key, msg, _ref;
      this._ERRORS = {};
      _ref = this.ERRORS;
      for (key in _ref) {
        msg = _ref[key];
        this._ERRORS[key] = _.template(msg);
      }
    };

    RedisSMQ.prototype._makeid = function(len) {
      var i, possible, text, _i;
      text = "";
      possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    };

    RedisSMQ.prototype._VALID = {
      qname: /^([a-zA-Z0-9_-]){1,80}$/,
      id: /^([a-zA-Z0-9:]){32}$/
    };

    RedisSMQ.prototype._validate = function(o, items, cb) {
      var item, _i, _len;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        switch (item) {
          case "qname":
          case "id":
            if (!o[item]) {
              this._handleError(cb, "missingParameter", {
                item: item
              });
              return false;
            }
            o[item] = o[item].toString();
            if (!this._VALID[item].test(o[item])) {
              this._handleError(cb, "invalidFormat", {
                item: item
              });
              return false;
            }
            break;
          case "vt":
          case "delay":
            o[item] = parseInt(o[item], 10);
            if (_.isNaN(o[item]) || !_.isNumber(o[item]) || o[item] < 0 || o[item] > 9999999) {
              this._handleError(cb, "invalidValue", {
                item: item,
                min: 0,
                max: 9999999
              });
              return false;
            }
            break;
          case "maxsize":
            o[item] = parseInt(o[item], 10);
            if (_.isNaN(o[item]) || !_.isNumber(o[item]) || o[item] < 1024 || o[item] > 65536) {
              this._handleError(cb, "invalidValue", {
                item: item,
                min: 1024,
                max: 65536
              });
              return false;
            }
        }
      }
      return o;
    };

    RedisSMQ.prototype.ERRORS = {
      "noAttributeSupplied": "No attribute was supplied",
      "missingParameter": "No <%= item %> supplied",
      "invalidFormat": "Invalid <%= item %> format",
      "invalidValue": "<%= item %> must be between <%= min %> and <%= max %>",
      "messageNotString": "Message must be a string",
      "messageTooLong": "Message too long",
      "queueNotFound": "Queue not found",
      "queueExists": "Queue exists"
    };

    return RedisSMQ;

  })(EventEmitter);

  module.exports = RedisSMQ;

}).call(this);
